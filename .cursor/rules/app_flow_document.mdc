---
description: Apply these rules when making changes to the project
globs:
alwaysApply: true
---

Update this rule if user requested changes to the project requirement, etc.
# App Flow Document

## Onboarding and Sign-In/Sign-Up
When a new user wants to start using Selin, they begin by cloning the project repository and preparing their environment. The user places their API token and any external service keys into Kubernetes Secrets or Sealed Secrets. These secrets are referenced by the deployment manifests managed with Kustomize and ArgoCD to ensure the system is configured without exposing credentials. There is no traditional web sign-up form or password management because the service is intended for a single user. Instead, the user’s token functions as an authentication credential. To access the API, the user includes this token in the HTTP Authorization header of each request. If the token is lost, the user creates a new secret in their Kubernetes cluster and updates the ArgoCD application, which triggers a redeploy to apply the new token. Signing out simply involves deleting or rotating that secret and updating the deployment.

## Main Dashboard or Home Page
Selin does not present a graphical dashboard to the user. Instead, once the user’s token has been applied, the main entry point is the REST API gateway at its base URL. A simple GET request to the root of the API returns a JSON object listing available endpoints such as the query submission endpoint and the WebSocket URI for real-time responses. From there, the user can navigate by choosing the appropriate URL paths and including their token in request headers. For real-time streaming answers, the user connects to the WebSocket service by opening a socket to the provided URI and authenticating with the same token. There is also an optional Grafana interface, deployed separately, which provides visual insights into system metrics, but that is primarily for monitoring and not required for regular learning workflows.

## Detailed Feature Flows and Page Transitions
When the user issues a learning query, they send a POST request to the `/query` endpoint of the API gateway, including their natural language prompt in the request body and their token in the header. The gateway first validates the token against Kubernetes Secrets and then checks Redis to enforce the limit of 60 requests per minute. If the user is within their quota, the gateway forwards the request payload to one of the MCP server instances running in the K3s cluster. The MCP server converts the user’s prompt into an embedding by calling the OpenAI embeddings API. With that embedding, it queries Weaviate to retrieve the top relevant content vectors. Parallel to that, the MCP server looks up the detailed metadata for each vector—such as source URL, author, timestamp, tags, content type, collection date, source platform, language, content summary, and relevance score—from PostgreSQL.

After gathering content and metadata, the MCP server constructs a structured prompt for Claude AI, streaming the prompt to Claude via the Claude MCP integration. As Claude generates its response, each chunk of text is sent back through the MCP server to the WebSocket service, which pushes it immediately to the user’s client. In the background, the MCP server logs the entire conversation and metadata in PostgreSQL for future analytics. If the user seeks to refine or clarify an answer, the in-memory session context in the MCP server keeps track of the conversation history so subsequent prompts can build on earlier ones.

## Settings and Account Management
All user preferences and system configuration live under the `user/` directory, where YAML files define sources, schedules, retention policies, and learning preferences. When the user edits `sources.yaml` to add or remove subreddits or GitHub repositories, or adjusts `schedules.yaml` to change how often collectors run, they commit those changes to Git. ArgoCD automatically detects updates and applies them via Kustomize to the running cluster. For subscription or billing settings, none are needed since there is a single user on a self-hosted system. Notifications and logging levels can also be configured in `preferences.yaml` and propagate without restarting the code, thanks to the hot-reload feature built into each Go microservice.

## Error States and Alternate Paths
If the user submits a request with an invalid or missing token, the API gateway returns a 401 Unauthorized response with an error message explaining the missing credential. When the user exceeds the rate limit, the gateway issues a 429 Too Many Requests response and includes a retry-after header indicating when the next request will be accepted. Should any downstream service such as Weaviate or the embeddings API fail, the MCP server catches the error, logs the incident to the centralized Loki store, and returns a 503 Service Unavailable with a user-friendly message suggesting they retry later. In network interruptions, WebSocket connections automatically attempt to reconnect, up to a configurable number of times, before falling back to an HTTP polling mode. Collector failures in the background trigger retries according to exponential backoff rules and send alerts via Alertmanager if repeated attempts continue to fail.

## Conclusion and Overall App Journey
From the moment the user deploys Selin and stores their token, they can immediately begin crafting questions against the REST API or WebSocket endpoint. Each query flows through authentication, rate limiting, vector retrieval, Claude AI processing, and real-time streaming back to their client. Meanwhile, the system continuously ingests new content on the schedules the user has defined, updates metadata, and refines learning recommendations. When preferences need adjustment, editing the YAML files and letting ArgoCD roll out changes is all it takes. Errors surface clearly with standard HTTP codes and messages, and monitoring dashboards give insight into both the dedicated server and Raspberry Pi cluster. In everyday use, the user quickly iterates on prompts, tracks their progress, and leverages personalized AI-driven insights to deepen their mastery of Go, blockchain, and cryptographic mathematics.